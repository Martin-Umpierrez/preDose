---
title: "exeval_ppk"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{exeval_ppk}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

This document presents a case of study to illustrates the external evaluation of a PPK model. The model and data come from Han, Nayoung, et al. "Prediction of the tacrolimus population pharmacokinetic parameters according to CYP3A5 genotype and clinical factors using NONMEM in adult kidney transplant recipients." European journal of clinical pharmacology 69.1 (2013): 53-63.

## Data and model 

First, we need to load the data and the model in `mrgsolve` format, both are preloaded in `preDose`package so they can be loaded usint `data()` funciton. 


```{r}
library(tidyverse)
library(preDose)

# load data and model code 
data(tacrolimus_pk1_kidney)
data(model_tacHAN2011)
```

Data consist in records for 49 patients, most of them meassured in 6 occassions and 2 or 3 times per ocassion.  (TODO: EXPLAIN REQUIRED DATA FORMAT)

```{r}
# Max OCC per ID 
tacrolimus_pk1_kidney |> 
  select(ID, OCC) |> 
  group_by(ID) |> 
  summarise( OCC = max(OCC) )  |> 
  group_by(OCC) |> 
  count()

# add a relevant plot of the data? 
```

The model object is simply a character string describing the PPK model in a format that `mrgsolve::mcode()` can interpret, 

```{r}
# PPK model text  
str(model_tacHAN2011)
```

## External evaluation 
Explain: 
  - external evaluation idea
  - evaluation type options
  - assesment options 

The whole procedure can be done calling the `exeval_ppk()` function, its minimal arguments are the model name and code, the data, 
and the type of evaluation and assesment, 
```{r}
res <- exeval_ppk(model_name = "HAN2011",
                  model = model_tacHAN2011,
                  data = subset(tacrolimus_pk1_kidney, ID < 6), 
                  evaluation_type= "Progressive", 
                  assessment='Bayesian_forecasting', 
                  verbose = FALSE )
```

## Results 

```{r}
res
```

Make some plots 
```{r}
metrics_plot_2(res$metrics, type = "bias_barplot")
```

## Compare models 

```{r, echo=FALSE}
ZuoX_etalfull_noCYP3A4 <-
  '$PROB
# One Comparment Model with first order absorption-
# CYP3A4*1G VARIABILITY
*1*1-------- n=73 ---- 45 %
*1*1G------- n=78----
*1G*1G------ n=10----- Combined 55 %

$GLOBAL
#define CP (CENT/iV)
$CMT  @annotated
EV   : Extravascular compartment
CENT : Central compartment


$PARAM @annotated
CL  :  26.6 : clearance (L/h)
V  :  1020   : central volume (L)
KA  : 3.09 : absorption rate constant (h-1)
ETA1 : 0 : Cl (L/h)
ETA2 : 0 : V (L/h)

$PARAM @annotated @covariate
HCT   : 0   : HEMATOCRITO ON CL
EXPRESSION      : 0  : If a patients has one *1 (0=no, 1=yes)
OCC     : -99  : Occasion, shall be passed by dataset imported

$MAIN

double HM = 1.1074 ;  ####High Metbolizer#### Considering CYP3A4 proportion
double PM = 0.68315 ;  ####Poor Metabolizer#### Considering CYP3A4 proportion

if(EXPRESSION== 1 )  double CL_EFFECT = HM  ;
if(EXPRESSION== 0 )  CL_EFFECT = PM  ;

double CL_HCT = - 0.451 ;  #### Hematocrit Effect on Clerance

double iCL =  CL * exp(ETA1 + ETA(1)) * CL_EFFECT * pow((HCT/27.9), CL_HCT)  ;
double iV =  V * exp(ETA2 + ETA(2)) ;
double iKA =  KA ;

$ODE
dxdt_EV = -iKA*EV;
dxdt_CENT = iKA*EV  - iCL*CP;


$OMEGA @name IIV
0.0569
0.294

$SIGMA  @name SIGMA @annotated
ADD : 2.1609 : ADD residual error
PROP : 0.0392 : Proportional residual error

$TABLE
double IPRED = CENT/iV;
double DV = IPRED * (1 + PROP) + ADD ;

$CAPTURE @annotated
OCC : OCCASION
CP : Plasma concentration (mass/volume)
iCL :  Clearance
iV : :Central Volume
iKA : KA: absorption rate constant
EVID : EVENT ID
DV : PREDICCION
OCC: OCCASION

               '
```


```{r}
# source("inst/model_examples/ZuoX_etal_2013.R")

resZ <- exeval_ppk(model_name = "ZuoX",
                  model = ZuoX_etalfull_noCYP3A4,
                  data = subset(tacrolimus_pk1_kidney, ID < 6), 
                  evaluation_type= "Progressive",                  assessment='Bayesian_forecasting' )

resALL <- list(
  list(model_name='HAN2011', metrics_list=res$metrics), 
  list(model_name = "ZuoX",  metrics_list=resZ$metrics)
  ) |> combine_metrics()  


plot_combined(resALL, 'bias_barplot')
```


Finally, `select_best_models()` function selects the best models from a dataframe of combined metrics based on a specified ranking metric.\
It requires a dataframe containing model evaluation metrics and the name of the metric to use for ranking.

Optionally, you can specify a particular occasion to focus on and the number of top models to select.

```{r model_selection, echo=TRUE, message=FALSE, warning=TRUE}

Best_fit <- select_best_models(resALL, metric = "rBIAS", top_n = 1)

Best_fit
```

## Intermediate steps in external evaluation process

TODO: update intermediate functions !!!!!!!

### Calculate individual parameters with `run_MAP_estimations`

The `run_MAP_estimations()` function returns a list with four elements:

-   **Observed data per occasion**: Includes the observed values for each individual in each occasion.

-   **Treatments per occasion**: Contains information on the treatments administered in each occasion.

-   **Estimated individual parameters**: Provides the MAP-estimated values of individual parameters for each subject and occasion.

-   **Mandatory** Used evaluation method (Progressive, Most_Recent_Progressive, Cronologic_Ref, Most_Recent_rEF) 

```{r map_estim, echo=TRUE, message=FALSE, warning=FALSE, eval=FALSE, cache=TRUE}
map.est <- run_MAP_estimations(model_name = "Test_Model",
                               model_code = Han_etal_test,
                               tool = "mapbayr",
                               data = external_data_mapbayr,
                               evaluation_type= "Progressive") 
```

### Update Individual Models with Estimated Parameters

Use `actualize_model()` to update each individual model using the parameters obtained from `run_MAP_estimations()`.

```{r indiviudal_Actualization, echo=TRUE,eval=FALSE, message=FALSE, warning=FALSE, cache=TRUE}
updt.md = actualize_model(map.est, evaluation_type = "Progressive") #### Individual Models
```

### Simulate Observed Concentrations
To simulate individual concentration profiles for each subject (ID) across all occasions (OCC), the `run_ind_simulations()` function requires the results from `run_MAP_estimations()` and updated individual parameters object from `actualize_model()`.

```{r Simulate, echo=TRUE, eval=FALSE, message=FALSE, warning=FALSE, error=FALSE, cache=TRUE}
sim = run_ind_simulations(updt.md, 
                          map.est,
                          assessment = "Bayesian_forecasting") # Simulate for every ID in every OCC

```

### Calculate Metrics Across Occasions
Use `metrics_occ()` to assess predictive performance by computing key metrics for each occasion.

```{r calcualte_metrics, echo=TRUE, eval=FALSE, message=FALSE}
metrics = metrics_occ(simulations= sim,
                      assessment= "Bayesian_forecasting",
                      tool="mapbayr") # Simulate for every ID in every OCC


```
